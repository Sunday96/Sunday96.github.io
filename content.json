{"meta":{"title":"剪刀手爱德华","subtitle":"菜鸟成长记录","description":null,"author":"Edward","url":"https://sunday9787.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-12-14T11:41:35.251Z","updated":"2020-12-14T11:41:35.251Z","comments":true,"path":"404.html","permalink":"https://sunday9787.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-12-14T15:19:49.184Z","updated":"2020-12-14T15:19:49.184Z","comments":true,"path":"about/index.html","permalink":"https://sunday9787.github.io/about/index.html","excerpt":"","text":"声明：本站所有文章除特别声明皆为原创，仅代表个人思想，与其他任何人或组织无关！技术更迭迅猛，部分内容可能会作修改，为保证信息与源同步，转载时请务必注明文章出处！谢谢合作 :-)"},{"title":"所有分类","date":"2020-12-14T12:24:51.266Z","updated":"2020-12-14T12:24:51.266Z","comments":true,"path":"categories/index.html","permalink":"https://sunday9787.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-12-14T15:20:26.943Z","updated":"2020-12-14T15:20:26.943Z","comments":true,"path":"friends/index.html","permalink":"https://sunday9787.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要提供名称、头像和链接哦。 名称: xxx头像: xxx地址: xxx标签: 技术大佬"},{"title":"","date":"2020-12-14T05:51:15.702Z","updated":"2020-12-14T05:51:15.702Z","comments":true,"path":"projects/index.html","permalink":"https://sunday9787.github.io/projects/index.html","excerpt":"","text":"node 博客系统技术栈 gulp 支持 typescript less scss es6 （支持环境变量） nodejs 全 typescript 开发 后台服务 （支持环境变量）使用 Koa 作为 web 服务框架，结合 koa-router 等中间件搭建 nodeJS web 服务 MongoDB 做数据库 使用 docker 作为部署工具 快速高效 Repositories: https://github.com/Sunday9787/blog-node countdown-ti一位大佬的简易倒计时，有幸能参与😀😀😀 支持 结束时间戳 日期字符串 剩余秒数 Repositories: https://github.com/Sunday9787/countdown-ti vue-multiple-page-demo一个自动格式化vue项目的配置例子根据 eslint 配置 或者 prettier 配置 自动格式化 支持 typescript tsx es6 Repositories: https://github.com/Sunday9787/vue-multiple-page-demo canvas-nest.js很有幸能参与到 这个3k的人气项目，添加了 typescript的支持，添加智能提示 提升开发体验（第一个 push request） Repositories: https://git.hust.cc/canvas-nest.js"},{"title":"所有标签","date":"2020-12-14T12:05:20.806Z","updated":"2020-12-14T12:05:20.806Z","comments":true,"path":"tags/index.html","permalink":"https://sunday9787.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2020年 vue面试","slug":"前端面试","date":"2020-07-31T06:35:20.000Z","updated":"2020-12-14T14:20:39.994Z","comments":true,"path":"2020/07/31/前端面试/","link":"","permalink":"https://sunday9787.github.io/2020/07/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/","excerpt":"","text":"Vue 相关 Vue实现数据双向绑定的原理：Object.defineProperty() Vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化 Vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 &#123;&#123;&#125;&#125;），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果 Vue 如何监听 Array的变化 先获取原生 Array 的原型方法 使用 Object.defineProperty 拦截 数组的原生操作 把需要被拦截的 Array 类型的数据原型指向改造后原型 然后再去做视图的更新等操作 1234567891011121314151617181920212223242526272829303132333435const arrayProto = Array.prototype // 获取Array的原型function def (obj, key) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, value: function(...args) &#123; console.log(key); // 控制台输出 push console.log(args); // 控制台输出 [Array(2), 7, &quot;hello!&quot;] // 获取原生的方法 let original = arrayProto[key]; // 将开发者的参数传给原生的方法，保证数组按照开发者的想法被改变 const result = original.apply(this, args); // do something 比如通知Vue视图进行更新 console.log(&#x27;我的数据被改变了，视图该更新啦&#x27;); this.text = &#x27;hello Vue&#x27;; return result; &#125; &#125;);&#125;// 新的原型let obj = &#123; push() &#123;&#125;&#125;// 重写赋值def(obj, &#x27;push&#x27;);let arr = [0];// 原型的指向重写arr.__proto__ = obj;// 执行pusharr.push([1, 2], 7, &#x27;hello!&#x27;); Vue.$nextTick有什么作用 当数据更新后 dom 会重新渲染，$nextTick就是为了可以在dom更新后立即拿到最新的dom对象 vue的优点是什么 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 Vue 组件 data 为什么必须是函数 每个组件都是 Vue 的实例 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其它实例 Virtual DOM 是什么？作用是什么一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象 提供与真实DOM节点所对应的虚拟节点vnode 将虚拟节点vnode和旧虚拟节点oldVnode进行对比，然后更新视图 v-for 的时候为什么要加 key更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的 不用key 就地复用节点。在比较新旧两个节点是否是同一个节点的过程中会判断成新旧两个节点是同一个节点，因为 a.key 和 b.key 都是 undefined。所以不会重新创建节点和删除节点，只会在节点的属性层面上进行比较和更新。所以可能在某种程度上（创建和删除节点方面）会有渲染性能上的提升； 无法维持组件的状态。由于就地复用节点的关系，可能在维持组件状态方面会导致不可预知的错误，比如无法维持改组件的动画效果、开关等状态； 用key 维持组件的状态，保证组件的复用。因为有 key 唯一标识了组件，不会在每次比较新旧两个节点是否是同一个节点的时候直接判断为同一个节点，而是会继续在接下来的节点中找到 key 相同的节点去比较，能找到相同的 key 的话就复用节点，不能找到的话就增加或者删除节点。 查找性能上的提升。有 key 的时候，会生成 hash，这样在查找的时候就是 hash 查找了，基本上就是 O(1) 的复杂度 节点复用带来的性能提升。因为有 key 唯一标识了组件，所以会尽可能多的对组件进行复用（尽管组件顺序不同），那么创建和删除节点数量就会变少，这方面的消耗就会下降，带来性能的提升。 Vue 和 React 的diff算法的区别vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。 vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性 vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。总体上，vue的对比方式更高效 Vue 与 Angular 以及 React的区别 与AngularJS的区别相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的 与React的区别相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性不同点： React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM JS 基础JS 基本类型有哪些？引用类型有哪些基本类型 存放在栈内存中，占据固定大小的空间 string number null boolean symbol undefined 引用类型 保存在堆内存中 function object array 介绍下 浅拷贝 深拷贝浅拷贝只赋值引用，没有赋值真正的值 深拷贝重新创建对象 切断 引用 123456789101112131415// @ts-expect-errorfunction deepcoyp&lt;T extends Record&lt;string, any&gt;&gt;(origin: T, target?: T = &#123;&#125;) &#123; for (const k in origin) &#123; if (origin.hasOwnProperty(k)) &#123; if (typeof origin[k] === &#x27;object&#x27; &amp;&amp; origin[k]) &#123; // @ts-expect-error target[k] = origin[k] instanceof Array ? [] : &#123;&#125;; deepcoyp(origin[k], target[k]); &#125; else &#123; target[k] = origin[k]; &#125; &#125; &#125; return target;&#125; JS 高级 prototype 和__proto__的区别 prototype 是函数的属性 【原型】 __proto__ 是每个对象拥有的属性 指向 构造函数原型 提示：__proto__ 该特性已经从 Web 标准中删除 应该使用 Object.getPrototypeOf() 来获取对象的原型 Javascript new一个对象的时候，内部发生了什么 创建一个空的简单JavaScript对象（即&#123;&#125;） 链接该对象（即设置该对象的构造函数）到另一个对象 将步骤1新创建的对象作为this的上下文 如果该函数没有返回对象，则返回this Object.create实现了什么？传null得到的结果和普通对象有什么区别 创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__得到一个 没有任何原型的对象，因为 null 是顶层对象 没有原型 import和require的区别 node编程中最重要的思想就是模块化，import和require都是被模块化所使用 出现的时间、地点不同require/exports 是社区产生的模块规范 2009年import/export 是 JS标准化模块规范 2015年 require/exports 是运行时动态加载，import/export 是静态编译CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 require/exports 输出的是一个值的拷贝，import/export 模块输出的是值的引用 用法不一致 防抖节流，它们两个之间的区别是什么 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时 函数节流（throttle）当持续触发事件时，保证一定时间段内只调用一次事件处理函数 说说你对闭包的理解闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在JavaScript中，函数即闭包，只有函数才会产生作用域 闭包有3个特性： 函数嵌套函数 在函数内部可以引用外部的参数和变量 参数和变量不会以垃圾回收机制回收 算法 构建二叉树123456789101112131415161718192021222324252627282930class BinaryTree &#123; public root: null | Node = null; public insert(key: number) &#123; const node = new Node(key); if (this.root) &#123; this.insertNode(this.root, node); return; &#125; this.root = node; &#125; private insertNode(node: Node, newNode: Node) &#123; // 节点值 小于 根节点 插入左边 反之 插入右边 if (newNode.key &lt; node.key) &#123; // 插入前 判断当前node 是否为空 是 生成节点 否则 继续 insertNode if (node.left === null) &#123; node.left = newNode; &#125; else &#123; this.insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; this.insertNode(node.right, newNode); &#125; &#125; &#125;&#125; 翻转二叉树123456789101112131415161718192021222324252627/* * 翻转二叉树 * 递归翻转 * 先判断 节点是否为空 * 首先 先 暂存 左右子节点 * 赋值 左右右节点 = 暂存右左节点; * 递归 左右节点 */class BinaryTree &#123; // more... private reverseNode(node: Node | null) &#123; if (!node) return; const tempLeft = node.left; const tempRight = node.right; node.right = tempLeft; this.reverseNode(node.right); node.left = tempRight; this.reverseNode(node.left); &#125; public reverse() &#123; this.reverseNode(this.root); &#125;&#125; 随机生成指定长度数组 且 值 唯一（洗牌算法）1234567891011121314151617/** * 洗牌 * 先生成指定长度数组，随后填充1-x值 * 再 排序 利用 (Math.random() &gt; 0.5 ? -1 : 1) 来随机排序 * @param size * @param domain */function shuffle(size: number, domain: number[]) &#123; const [min, max] = domain; return Array(max) .fill(0) .map((_, i) =&gt; i + 1) .sort(() =&gt; (Math.random() &gt; 0.5 ? -1 : 1)) .filter(v =&gt; v &lt;= max &amp;&amp; v &gt;= min) .slice(0, size);&#125; 两数之和123456789101112131415161718192021222324252627/** * 两数之和 * 利用堆 存储 已经遍历过的下标和值 * 下标做 key 值 value nums = &#123;0: xxx&#125;; * 循环一次 * 从 nums 获取 当前下标的值 curNum = nums[0] * target - curNum 得到 key * 如果 curNum[key] 不为 undefined 即 得到 另外一个 数 * @export * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @returns */export function twoSum(nums: number[], target: number) &#123; const prevNums: Record&lt;string, number&gt; = &#123;&#125;; // 存放出现过的数字，和对应的索引 for (let i = 0; i &lt; nums.length; i++) &#123; // 遍历每一项 const curNum = nums[i]; // 当前项 const targetNum = target - curNum; // 希望从过去的数字中找到的呼应项 const targetNumIndex = prevNums[targetNum]; // 在prevNums中找targetNum的索引 if (targetNumIndex !== undefined) &#123; return [targetNumIndex, i]; // 直接返回targetNumIndex和当前的i &#125; // 如果找不到，说明之前没出现过targetNum prevNums[curNum] = i; // 往prevNums存当前curNum和对应的i &#125;&#125; 数组去重1234567891011121314/** * 利用 filter indexOf * indexOf 返回第一次找到的元素下标，如果下标跟返回的下标不一致说明重复 * @export * @template T * @param &#123;T[]&#125; arr * @returns */export function unique3&lt;T extends number&gt;(arr: T[]) &#123; console.time(&#x27;unique3&#x27;); const result: T[] = arr.filter((item, index) =&gt; arr.indexOf(item, 0) === index); console.timeEnd(&#x27;unique3&#x27;); return result;&#125; 数组排序123456789101112131415161718192021222324252627/** * 选择排序 * @description 首先从原始数组中找到最小的元素，并把该元素放在数组的最前面，然后再从剩下的元素中寻找最小的元素，放在之前最小元素的后面，知道排序完毕。 * * @export * @param &#123;number[]&#125; arr * @returns */export function selectSort2(arr: number[]) &#123; let minIndex = 0, temp; const length = arr.length; for (let i = 0; i &lt; length - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 找到 最小值 index minIndex = j; &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; JS 中的广度与深度优先遍历 深度优先 123456789101112/** * 深度遍历 * @param node */export function deepTraversal&lt;T extends Node&gt;(node: T) &#123; console.log(node); if (node.childNodes) &#123; Array.prototype.forEach.call(node.childNodes, (item: T) =&gt; &#123; deepTraversal(item); &#125;); &#125;&#125; 广度优先 1234567891011121314151617181920/** * 广度优先 * * @export * @template T * @param &#123;T&#125; node */export function breadthTraversal&lt;T extends Node&gt;(node: T) &#123; const queue: T[] = []; queue.unshift(node); while (queue.length) &#123; const childrenItem = queue.pop()!; console.log(childrenItem); const childrenList: T[] = Array.prototype.slice.call(childrenItem.childNodes, 0); for (let i = 0; i &lt; childrenList.length; i++) &#123; queue.push(childrenList[i]); &#125; &#125;&#125; webpack 你都用过哪些webpack的配置 mode 模式 entry 入口 output 出口 文件名 路径配置 resolve extensions 可被解析的 文件后缀 alias 别名 externals 外部依赖 module 配置 模块解析 plugin和loader的区别 loader 用于加载解析某些资源文件例如 把.ts 编译成 js，把小图片转换成 base64，把.scss 编译成 css 等等，只针对转化文件 plugin 用于扩展webpack的功能它直接作用于 webpack，扩展了它的功能。当然loader也是变相的扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域。而plugin的功能更加的丰富，而不仅局限于资源的加载例如 定义环境变量，压缩js css 等等，开启 dev-server 用过哪些loader、pluginloader vue-loader ts-loader sass-loader vue-style-loader style-loader postcss-loader plugin html-webpack-plugin 结合 webpack-dev-server mini-css-extract-plugin 把css 输出成css 文件 uglifyjs-webpack-plugin 把 压缩css / js 文件 HTTP 谈谈你对http协议的认识http协议是基于一种请求/响应模式的、无状态的、应用层的协议，基于TCP协议传输数据，支持客户/服务器模式，每次完整交互都包含HTTP请求和HTTP响应。 Http请求由三个部分组成，请求行、消息报头、请求正文（可选，为空也行） 请求方法主要包括：GET、POST、HEAD、PUT、DELETE… GET：请求获取Request-URI所标识的资源 POST：在Request-URI所标识的资源后附加新的数据（body） 每种方法规定了客户与服务器联系的类型不同，由于http协议简单，使得http服务器的程序规模小，因而通信速度快 HTTP Request Header 请求头 Accept: 允许哪些媒体类型 Accept-Charset: 允许哪些字符集 Accept-Encoding: 允许哪些编码 Accept-Language: 允许哪些语言 Cache-Control: 缓存策略，如no-cache 如max-age:100 Connection: 连接选项，例如是否允许代理 Host: 请求的主机 Referer: 表明这个请求发起的源头 HTTP Responses Header 响应头 Accept-Ranges：表明服务器是否支持指定范围请求及哪种类型的分段请求 Age：从原始服务器到代理缓存形成的估算时间（以秒计，非负） Allow：对某网络资源的有效的请求行为，不允许则返回405 Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型 Content-Encodingweb：服务器支持的返回内容压缩编码类型 Content-Language：响应体的语言 Content-Length：响应体的长度 Content-Type：返回内容的MIME类型 Expires：响应过期的日期和时间 HTTP状态码有哪些？代表什么意思HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表: 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://sunday9787.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"webpack+ts+es6+vue 配置教程","slug":"webpack-ts-es6-vue","date":"2020-07-17T14:46:52.000Z","updated":"2020-12-14T16:42:05.259Z","comments":true,"path":"2020/07/17/webpack-ts-es6-vue/","link":"","permalink":"https://sunday9787.github.io/2020/07/17/webpack-ts-es6-vue/","excerpt":"之前一直搞不懂webpack，也排斥学习 总是觉得太难了 配置太复杂。。。 最近一段时间没事写写轮播图玩，传统dom形式是写通了，我想拿到vue, react用呢？","text":"之前一直搞不懂webpack，也排斥学习 总是觉得太难了 配置太复杂。。。 最近一段时间没事写写轮播图玩，传统dom形式是写通了，我想拿到vue, react用呢？ 理解webpack如何配置？ 打造自己的组件库？ 那么现在开始吧 Webpack 的四大核心 entery 入口源文件 output 生成文件出口 loader 进行文件处理 plugins 插件，比 loader 更强大，能使用更多 webpack 的 api 下面配置一个 vue + ts + tsx webpack配置【基于v4】 第一步 配置 入口出口模块先把入口出口模块配置 123456789101112131415module.exports = &#123; mode: process.env.NODE_ENV, // 启用不同类型的 mode 得到的优化效果不一样 devtool: &#x27;source-map&#x27;, // webpack serve 运行的时候 添加 source-map entry: util.resolve(&#x27;src/components/main.ts&#x27;), // 入口文件 output: &#123; filename: &#x27;index.js&#x27;, // 打包后的文件名 path: util.resolve(&#x27;dist&#x27;), // 输出的目录 publicPath: &#x27;/&#x27;, // 结合 HtmlWebpackPlugin 使用，定义资源基准地址 // chunkFilename: &#x27;[id].js&#x27;, // 哈希name libraryTarget: &#x27;umd&#x27;, // 打包成什么类型模块 如果打包成 common 模块推荐 commonjs2 library: &#x27;swiper&#x27;, // 对外暴露的模块名称 umdNamedDefine: true, // 如果设置了 libraryTarget： &#x27;umd&#x27; 则 需要设置 umdNamedDefine: true &#125;, // ...more&#125; 第二步 配置可以被解析的文件配置 可以被解析的文件 因为我们要支持ts和vue打包，所以 extensions 要加 .vue .ts 再配置一个别名 方便我们 在项目中 import 例如 import xxx form &#39;@/xxxx&#39; 123456789module.exports = &#123; // ...more resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;, &#x27;.ts&#x27;], // 可以被解析的文件 alias: &#123; &#x27;@&#x27;: util.resolve(&#x27;src&#x27;), // 别名 tsconfig 也同样需要配置一份 详见 tsconfig `paths`选项 &#125;, &#125;,&#125; 第三步 配置外部资源配置 外部资源，这些资源不需要被打包在一起 1234module.exports = &#123; // ...more externals: [&#123; vue: &#x27;Vue&#x27; &#125;], // 外部已经有的依赖模块 至于为何是 数组 或者对象 字符串 还是自己百度一下实际测试，我说的可能不太对，总的来说是 模块对外暴露的名称 和 模块 名称&#125; 第四步 配置 module配置 module 我们想 打包一个vue + ts/tsx scss 需要用到什么loader？ vue 肯定要 vue-loader ts ts-loader scss sass-loader loader 的执行顺序是 从 右 到 左 切记 loader顺序错误依然不会正确打包 解析 .ts 首先要通过ts-loader 检查ts类型校验 然后 被编译成esnext 模块，babel-loader 再编译成浏览器能处理的js模块和js版本 123456789101112module.exports = &#123; // ...more module: &#123; rules: [ // ...more &#123; test: /\\.ts$/i, loader: &#x27;babel-loader!ts-loader&#x27;, // 处理ts文件 loader 传递loader的名称 ! 代表 多个loader分隔符 简写【猜的。。。】 &#125;, ], &#125;&#125; 解析 .tsx 123456789101112131415161718192021module.exports = &#123; // ...more module: &#123; rules: [ // ...more &#123; test: /\\.tsx$/i, use: [ &#123; loader: &#x27;babel-loader&#x27; &#125;, // ts 处理完后 交给 babel 编译成 普通 js文件 es5版本(根据babel配置) &#123; loader: &#x27;ts-loader&#x27;, options: &#123; appendTsSuffixTo: [/\\.vue$/], // 让 ts 支持 .vue 文件处理 敲黑板 这一步不要忘记 场景 .tsx 文件中去引入 .vue组件 引用链接 https://segmentfault.com/a/1190000012024858 &#125;, &#125;, ], exclude: util.resolve(&#x27;node_modules&#x27;), // 不处理的目录 &#125;, ], &#125;&#125; 解析 .scss这一步需要先配置 sass-loader 然后交给 postcss-loader 自动添加浏览器前缀再交给 css-loader再 交给 MiniCssExtractPlugin.loader 导出.css 文件 12345678910111213141516171819202122232425262728module.exports = &#123; // ...more module: &#123; // ...more rules: [ &#123; test: /\\.s[ac]ss$/i, use: [ &#123; loader: MiniCssExtractPlugin.loader, // 导出为.css options: &#123; publicPath: &#x27;/&#x27;, hmr: process.env.NODE_ENV === &#x27;development&#x27;, // css 热更新 &#125;, &#125;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;, // 帮助自动添加浏览器后缀 &#123; loader: &#x27;sass-loader&#x27;, options: &#123; implementation: require(&#x27;dart-sass&#x27;), // 默认使用的是 node-sass node-sass 下载巨慢。。。 推荐 dart-sass 下载速度还快 &#125;, &#125;, ], &#125;, ] &#125;&#125; 最后奉上 最终配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;); // vue-loader 的所有插件 处理template .vue专用 插件const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;); // webpack 加载一个 html 作为 结果展示页const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;); // 压缩jsconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;); // 把 css 文件导出到本地const util = require(&#x27;./util&#x27;); // 工具包/** * @type &#123;import(&#x27;webpack&#x27;).Configuration&#125; */module.exports = &#123; mode: process.env.NODE_ENV, // 启用不同类型的 mode 得到的优化效果不一样 devtool: &#x27;source-map&#x27;, // webpack serve 运行的时候 添加 source-map entry: util.resolve(&#x27;src/components/main.ts&#x27;), // 入口文件 output: &#123; filename: &#x27;index.js&#x27;, // 打包后的文件名 path: util.resolve(&#x27;dist&#x27;), // 输出的目录 publicPath: &#x27;/&#x27;, // 结合 HtmlWebpackPlugin 使用，定义资源基准地址 // chunkFilename: &#x27;[id].js&#x27;, // 哈希name libraryTarget: &#x27;umd&#x27;, // 打包成什么类型模块 如果打包成 common 模块推荐 commonjs2 library: &#x27;swiper&#x27;, // 对外暴露的模块名称 umdNamedDefine: true, // 如果设置了 libraryTarget： &#x27;umd&#x27; 则 需要设置 umdNamedDefine: true &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;, &#x27;.ts&#x27;], // 可以被解析的文件 alias: &#123; &#x27;@&#x27;: util.resolve(&#x27;src&#x27;), // 别名 tsconfig 也同样需要配置一份 详见 tsconfig `paths`选项 &#125;, &#125;, externals: [&#123; vue: &#x27;Vue&#x27; &#125;], // 外部已经有的依赖模块 module: &#123; // loader 执行顺序是 从 右 到 左 rules: [ &#123; test: /\\.ts$/i, loader: &#x27;babel-loader!ts-loader&#x27;, // 处理ts文件 loader 传递loader的名称 ! 代表 多个loader分隔符 简写【猜的。。。】 &#125;, &#123; test: /\\.tsx$/i, use: [ &#123; loader: &#x27;babel-loader&#x27; &#125;, &#123; loader: &#x27;ts-loader&#x27;, options: &#123; appendTsSuffixTo: [/\\.vue$/], // 让 ts 支持 .vue 文件处理 &#125;, &#125;, ], exclude: util.resolve(&#x27;node_modules&#x27;), // 不处理的目录 &#125;, &#123; test: /\\.(es6|js|mjs)$/i, include: util.resolve(&#x27;src&#x27;), // 可以被处理的目录 exclude: util.resolve(&#x27;node_modules&#x27;), use: [ &#123; loader: &#x27;babel-loader&#x27;, &#125;, ], &#125;, &#123; test: /\\.vue$/i, loader: &#x27;vue-loader&#x27;, // .vue 文件 vue-loader 会把他们处理成 .js .css, options: &#123; // 所以 对 于 这种类型文件 需要 再配置 loader loaders: &#123; js: &#x27;babel-loader&#x27;, ts: &#x27;babel-loader!ts-loader&#x27;, tsx: &#x27;babel-loader!ts-loader&#x27;, // 好像这个不需要。。。我没试过 .vue || tsx 只能选一个 &#125;, compilerOptions: &#123; preserveWhitespace: false, // 放弃模板标签之间的空格 详看 https://vue-loader.vuejs.org/zh/options.html#compiler &#125;, &#125;, &#125;, &#123; test: /\\.css$/, use: [&#x27;css-loader&#x27;], &#125;, &#123; test: /\\.s[ac]ss$/i, use: [ &#123; loader: MiniCssExtractPlugin.loader, // 导出为.css options: &#123; publicPath: &#x27;/&#x27;, hmr: process.env.NODE_ENV === &#x27;development&#x27;, // css 热更新 &#125;, &#125;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;, // 帮助自动添加浏览器后缀 &#123; loader: &#x27;sass-loader&#x27;, options: &#123; implementation: require(&#x27;dart-sass&#x27;), // 默认使用的是 node-sass node-sass 下载巨慢。。。 推荐 dart-sass 下载速度还快 &#125;, &#125;, ], &#125;, ], &#125;, plugins: [ new VueLoaderPlugin(), new MiniCssExtractPlugin(&#123; // filename: &#x27;[name].[chunkhash:8].css&#x27;, // 哈希name `chunkhash` 打包为库之类的不需要哈希，只有实际业务开发打包的文件最好加哈希 // chunkFilename: &#x27;[id].[chunkhash:8].css&#x27;, &#125;), new HtmlWebpackPlugin(&#123; title: &#x27;My App&#x27;, filename: &#x27;index.html&#x27;, template: util.resolve(&#x27;public/index.html&#x27;), // inject: &#x27;head&#x27;, // 把打包后的资源链接 插入到 HTML那个位置 &#125;), ], stats: &#x27;normal&#x27;, // 打包控制台输出的信息 类别 optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: util.resolve(&#x27;.cache&#x27;), parallel: true, sourceMap: true, &#125;), ], &#125;,&#125;; 那么有什么问题 可以留言，请多多指教","categories":[{"name":"webpack","slug":"webpack","permalink":"https://sunday9787.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://sunday9787.github.io/tags/webpack/"},{"name":"ts","slug":"ts","permalink":"https://sunday9787.github.io/tags/ts/"},{"name":"vue","slug":"vue","permalink":"https://sunday9787.github.io/tags/vue/"}]},{"title":"科学上网","slug":"科学上网","date":"2020-07-09T08:47:17.000Z","updated":"2020-12-14T14:01:31.779Z","comments":true,"path":"2020/07/09/科学上网/","link":"","permalink":"https://sunday9787.github.io/2020/07/09/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/","excerpt":"V2Ray是近几年兴起的科学上网技术，采用新的协议，因功能强大、能有效抵抗墙的干扰而广受好评，ssr 已被GFW识别，封禁率高，已不再推荐V2Ray 同时支持 ssr vmess 协议","text":"V2Ray是近几年兴起的科学上网技术，采用新的协议，因功能强大、能有效抵抗墙的干扰而广受好评，ssr 已被GFW识别，封禁率高，已不再推荐V2Ray 同时支持 ssr vmess 协议 软件 客户端 地址 Windows V2rayN Mac V2rayX Android V2rayNG IOS Shadowrocket（需要注册非大陆AppleID，或者购买）需要付费 配置V2rayN 下载 &amp; 解压 v2rayN-Core.zip v2rayN.zip 双击运行 v2rayN.exe 配置vmess服务器 可以从剪贴板 导入 最后启动 选择 pac模式 或者 全局模式 下载 copy v2rayN-Core 下的所有文件到 v2rayN 配置 双击运行 v2rayN.exe 单击 v2ray 图标 点击服务器 从剪贴板批量导入链接 启动 右击 v2ray 图标 服务-&gt; 启动pac V2rayX 下载后 拖到 application 应用程序文件夹内 双击运行，如果有弹出安全策略不允许运行，请打开系统偏好设置 -&gt; 安全与隐私 仍然打开 然后 点击桌面上方 v2rayX图标 -&gt; Configure -&gt; import other links （导入vmess://xxx类型链接） 最重要一步 v2rayX图标 -&gt; load core 启动服务 安装 下载后 application 应用程序文件夹内 双击运行，如果有弹出安全策略不允许运行，请打开系统偏好设置 -&gt; 安全与隐私 仍然打开 点击 install 配置 Configure 一般建议选择 pac mode，匹配规则，规则内网站走代理，其他直连 global mode 全局模式，所有网站走代理（这里全局仅仅是针对浏览网页） Manual mode 直连模式，所有网站不走代理 配置服务器 import other links 最后一步 load core V2rayNG 暂无安卓设备，参考以上配置即可 Shadowrocket 支持的协议很多 ssr、vmess、trojan 需要切换非中国大陆AppleID下载安装，可以在 某宝 某多 买到帐号 copy vmess://xxx 链接 进入 Shadowrocket 会自动提示你 是否导入 切换节点 然后 开启 服务就行了","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://sunday9787.github.io/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"https://sunday9787.github.io/tags/v2ray/"},{"name":"小飞机","slug":"小飞机","permalink":"https://sunday9787.github.io/tags/%E5%B0%8F%E9%A3%9E%E6%9C%BA/"}]},{"title":"dom-tips","slug":"tips","date":"2020-07-05T08:30:58.000Z","updated":"2020-12-14T15:12:06.211Z","comments":true,"path":"2020/07/05/tips/","link":"","permalink":"https://sunday9787.github.io/2020/07/05/tips/","excerpt":"时常看别人博客添加了各种效果，有些好奇 想自己实现一个，今天就来实现一个 点击 页面 弹出 一个tips块","text":"时常看别人博客添加了各种效果，有些好奇 想自己实现一个，今天就来实现一个 点击 页面 弹出 一个tips块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465interface TipsOptions &#123; messages: string | string[]; className?: string;&#125;export class Tips &#123; public className?: string; public messages: string[]; public count = 0; constructor(options: TipsOptions) &#123; this.messages = options.messages instanceof Array ? options.messages : [options.messages]; this.className = options.className; &#125; public render(): void &#123; const self = this; const messageLength = this.messages.length; document.addEventListener(&#x27;click&#x27;, function (event: MouseEvent) &#123; self.count++; const el = this.createElement(&#x27;div&#x27;); // el.innerText = self.messages[self.count % messageLength]; el.innerText = self.messages[Math.floor(Math.random() * messageLength)]; if (self.className) &#123; el.classList.add(self.className); &#125; el.style.maxWidth = &#x27;60px&#x27;; el.style.color = &#x27;red&#x27;; el.style.cursor = &#x27;default&#x27;; el.style.userSelect = &#x27;none&#x27;; el.style.opacity = &#x27;0&#x27;; el.style.transitionDuration = &#x27;200ms&#x27;; el.style.position = &#x27;absolute&#x27;; el.style.top = event.pageY + &#x27;px&#x27;; this.body.appendChild(el); /* * 水平 点击 位置居中 * offsetWidth 必须要等元素插入dom中后才能获取到 */ el.style.left = event.pageX - el.offsetWidth / 2 + &#x27;px&#x27;; console.log(event.pageX, el.style.left, el.offsetWidth, event.pageX - el.offsetWidth / 2); // 等待 前面执行栈执行完毕 立即插入任务队列 setTimeout(function () &#123; el.style.opacity = &#x27;1&#x27;; // 垂直浮动 最高 50px 距离 el.style.transform = `translateY($&#123;-Math.floor(Math.random() * 50)&#125;px)`; &#125;, 0); setTimeout(() =&gt; &#123; el.style.opacity = &#x27;0&#x27;; // 过渡动画 是 200ms 故 延时200 移除dom setTimeout(() =&gt; &#123; this.body.removeChild(el); &#125;, 200); &#125;, 3000); &#125;); &#125;&#125; 效果完工","categories":[],"tags":[{"name":"dom","slug":"dom","permalink":"https://sunday9787.github.io/tags/dom/"}]},{"title":"element-form resetFields 与 Vue $nextTick","slug":"element-form","date":"2019-10-07T05:49:03.000Z","updated":"2020-12-14T05:51:15.684Z","comments":true,"path":"2019/10/07/element-form/","link":"","permalink":"https://sunday9787.github.io/2019/10/07/element-form/","excerpt":"公司之前一个管理后台做好了，拿给客户演示后，提了新的需求，url传递参数 页面自动显示 action form 表单，且 form表单内数据是传递来的参数 想了下这个需求很简单，router传递参数吗 easy, mounted 后 把 query的参数 赋值到 form","text":"公司之前一个管理后台做好了，拿给客户演示后，提了新的需求，url传递参数 页面自动显示 action form 表单，且 form表单内数据是传递来的参数 想了下这个需求很简单，router传递参数吗 easy, mounted 后 把 query的参数 赋值到 form 本示例模拟 参数已经从url拿到 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;el-button type=&quot;text&quot; @click=&quot;dialogVisible = true&quot;&gt;点击打开 Dialog&lt;/el-button&gt; &lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; @closed=&quot;closed&quot;&gt; &lt;el-form :model=&quot;form&quot; label-width=&quot;100px&quot; ref=&quot;form&quot;&gt; &lt;el-form-item label=&quot;审批人&quot; prop=&quot;user&quot;&gt; &lt;el-input v-model=&quot;form.user&quot; placeholder=&quot;审批人&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;活动区域&quot;&gt; &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;活动区域&quot; style=&quot;width: 100%;&quot;&gt; &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot; /&gt; &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button @click=&quot;dialogVisible = false&quot;&gt;取 消&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt;&lt;/div&gt; 12345678910111213141516171819202122232425var Main = &#123; data() &#123; return &#123; form: &#123; user: &#x27;&#x27;, region: &#x27;&#x27; &#125;, dialogVisible: false, &#125; &#125;, mounted() &#123; if (true) &#123; this.dialogVisible = true this.form.user = &#x27;55555&#x27; &#125; &#125;, methods: &#123; closed() &#123; this.$refs.form.resetFields() &#125; &#125;&#125;var Ctor = Vue.extend(Main)new Ctor().$mount(&#x27;#app&#x27;) 这样么错吧 12this.dialogVisible = truethis.form.user = &#x27;55555&#x27; 但是 关闭的时候 重置form 的时候，无法清空 值 在线地址，不管你输入什么 关闭后还是 我们在 mounted 赋的新值 5555 我百思不得琪姐 忽然灵光一闪 this.$nextTick 没错就是它了 来理解一下 Vue.$nextTick 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM 1234567891011// 修改数据vm.msg = &#x27;Hello&#x27;// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;)// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)Vue.nextTick().then(function () &#123; // DOM 更新了&#125;) 为何数据修改后没有立即更新DOM? Vue 异步更新队列 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 从Vue文档解释 再重新来 理解 这段代码 12this.dialogVisible = truethis.form.user = &#x27;55555&#x27; 先把 弹窗弹出 这个时候 Dialog 在初始化显示（此时并不能获取form），dom 没有完全更新完毕 然后 执行了 给form 赋值动作，form这个时候并没有渲染，还未初始化（那么就相当于 form 的初始默认值是 ‘55555’）全部初始化后 弹框内 form 表单默认值是 有了 ‘5555’，但是关闭的时候这个值并没有被清空this.$refs.form.resetFields() 也执行了 这是因为 element的form resetFields()方法这个方法 还原了 form 的默认值，默认值就是我们赋值的 ‘5555’ 因为我们没有在 dom完全更新后 去赋新的值，element-form 没有初始化，我们赋新的值 ‘5555’ 自然是 默认值 this.$refs.form.resetFields() 自然还原了”默认值” 小结 this.$nextTick 保证了数据更新后DOM完全渲染完毕后，数据，视图的正确性，要善于利用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sunday9787.github.io/categories/Vue/"}],"tags":[{"name":"element-form","slug":"element-form","permalink":"https://sunday9787.github.io/tags/element-form/"},{"name":"$nextTick","slug":"nextTick","permalink":"https://sunday9787.github.io/tags/nextTick/"}]},{"title":"target='_blank' 安全漏洞","slug":"target=_blank","date":"2019-09-16T14:19:20.000Z","updated":"2020-12-14T16:40:25.848Z","comments":true,"path":"2019/09/16/target=_blank/","link":"","permalink":"https://sunday9787.github.io/2019/09/16/target=_blank/","excerpt":"不知道有没有人跟我一样 打开一个网站喜欢 ctrl + shift + i 😀 不过有时候会发现 a 标签 加了一些东西 1&lt;a href=&quot;xxx&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;","text":"不知道有没有人跟我一样 打开一个网站喜欢 ctrl + shift + i 😀 不过有时候会发现 a 标签 加了一些东西 1&lt;a href=&quot;xxx&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt; 先解释一下 a 标签 rel 属性是什么意思 引用MDN 该属性指定了目标对象到链接对象的关系。该值是空格分隔的列表类型值。 noreferrer 阻止浏览器跳到另一个页面时，通过HTTP头，发送当前页面的名字或其他值，以及把当前页设为另一个页面的引用(另一个页面的referrer值 ) noopener 单击链接时隐藏引用者信息 阻止打开不受信任的链接时 以确保它们不会通过 window.opener (返回打开当前窗口的那个窗口的引用) 属性篡改原始文档 nofollow 表示本文档的作者不想宣传链接的文档，例如，它是不受控的，它是一个坏的例子或如果它们有商业关系（销售环节）。nofollow主要是被一些使用人气排名技术的搜索引擎所使用 ok 为什么要用这个呢想一下 如果你的网站内 有其他网站链接的时候，有时候 新页面白了一下就没了，原页面发现不见了 变成了其他网站。 很可能是 中了钓鱼网站如果新打开的tab 页面没有关闭，它会持续的保持对原页面的访问权，这样一来别人就可以做很多事情 在用户点击到钓鱼链接后 主要是由用户发布的链接 攻击者可以通过使用 window.opener.location 强迫用户的前一个页面跳转到钓鱼页面，欺骗用户在钓鱼页面上登录，窃取用户口令。 12345&lt;html lang=&quot;en&quot;&gt;&lt;body&gt; &lt;a href=&quot;http://www.b.com&quot; target=&quot;_blank&quot;&gt;http://www.b.com&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 12345678910&lt;!-- b.com下的页面 --&gt;&lt;html lang=&quot;en&quot;&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; if (opener) &#123; opener.window.location.href=&quot;https://google.com&quot;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有些高版本浏览器已修复这个bug 但是 为了确保安全建议所有站外链接全部添加 nofollow noopener noreferrer","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://sunday9787.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"填字游戏","slug":"填字游戏","date":"2018-04-01T08:57:30.000Z","updated":"2020-12-14T14:42:59.192Z","comments":true,"path":"2018/04/01/填字游戏/","link":"","permalink":"https://sunday9787.github.io/2018/04/01/%E5%A1%AB%E5%AD%97%E6%B8%B8%E6%88%8F/","excerpt":"起初是公司一个小游戏，从立项到开发完成大概5天吧，因为时间有些赶，最开始写的并不是很好，画字格用的是 table。UI上面小小出入，跟一个朋友说做这个项目后，朋友建议我用 pixijs，利用闲暇时间重写了一遍，下面是源码","text":"起初是公司一个小游戏，从立项到开发完成大概5天吧，因为时间有些赶，最开始写的并不是很好，画字格用的是 table。UI上面小小出入，跟一个朋友说做这个项目后，朋友建议我用 pixijs，利用闲暇时间重写了一遍，下面是源码 HTML12345678910111213&lt;p class=&quot;time-container&quot;&gt;&lt;time id=&quot;time&quot;&gt;00:00&lt;/time&gt;&lt;/p&gt;&lt;div class=&quot;game-container&quot;&gt; &lt;canvas id=&quot;game&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; &lt;div class=&quot;mask&quot;&gt;初始化中...&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;tips-container&quot;&gt; &lt;p class=&quot;fl&quot;&gt;提示：&lt;/p&gt; &lt;p id=&quot;tips&quot; class=&quot;oh&quot;&gt;赫拉利将告诉你人类是如何从动物变成上帝&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;game-input&quot; id=&quot;game-input&quot; /&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;game-input-send&quot;&gt;确认&lt;/a&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511require([&quot;zepto&quot;, &quot;pixi&quot;, &quot;modal&quot;], function($, pixi, modal) &#123; // 游戏基础配置 modal.pupup(&#123; content: ` &lt;!-- &lt;img src=&quot;http://sunday90.cn/upload/2500872220b52768dd9c4e237579f8bc.jpg&quot; /&gt; --&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;btn start-btn&quot;&gt;开始计时&lt;/a&gt; `, mask: true, success: function(layero) &#123; const that = this; $(layero).on(&quot;click&quot;, &quot;.start-btn&quot;, function(e) &#123; console.log(this); console.log(&quot;开始游戏&quot;); let time = document.querySelector(&quot;#time&quot;); Countdown.start(0.2, time, function(time) &#123; console.log(time); &#125;); that.close(); &#125;); &#125; &#125;); const ua = window.navigator.userAgent.toLocaleLowerCase(); const device = &#123; ios: /iphone/g.test(ua), android: /android/g.test(ua) &#125;; const unit_size = &#123; width: 50, height: 50 &#125;; const table = &#123; x: 10, y: 10 &#125;; const gameContainer = document.querySelector(&quot;.game-container&quot;); const mask = document.querySelector(&quot;.mask&quot;); const input = document.querySelector(&quot;#game-input&quot;); const tipsEl = document.querySelector(&quot;#tips&quot;); const fontStyle = new PIXI.TextStyle(&#123; fontFamily: &#x27;-apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif&#x27;, fontSize: 28, fontWeight: &quot;500&quot;, fill: [&quot;#333&quot;] // gradient &#125;); const time = document.querySelector(&quot;#time&quot;); // 需要渲染的方格二维数组 const unit_data = [ [ &#123; y: 0, x: 1 &#125;, &#123; y: 0, x: 5 &#125;, &#123; y: 0, x: 6 &#125;, &#123; y: 0, x: 7 &#125;, &#123; y: 0, x: 8 &#125; ], [ &#123; y: 1, x: 1 &#125;, &#123; y: 1, x: 3 &#125;, &#123; y: 1, x: 8 &#125; ], [ &#123; y: 2, x: 1 &#125;, &#123; y: 2, x: 2 &#125;, &#123; y: 2, x: 3 &#125;, &#123; y: 2, x: 4 &#125;, &#123; y: 2, x: 6 &#125;, &#123; y: 2, x: 7 &#125;, &#123; y: 2, x: 8 &#125; ], [ &#123; y: 3, x: 3 &#125;, &#123; y: 3, x: 7 &#125; ], [ &#123; y: 4, x: 0 &#125;, &#123; y: 4, x: 1 &#125;, &#123; y: 4, x: 2 &#125;, &#123; y: 4, x: 3 &#125;, &#123; y: 4, x: 6 &#125;, &#123; y: 4, x: 7 &#125;, &#123; y: 4, x: 8 &#125;, &#123; y: 4, x: 9 &#125; ], [ &#123; y: 5, x: 1 &#125;, &#123; y: 5, x: 7 &#125; ], [ &#123; y: 6, x: 1 &#125;, &#123; y: 6, x: 4 &#125;, &#123; y: 6, x: 5 &#125;, &#123; y: 6, x: 6 &#125;, &#123; y: 6, x: 7 &#125; ], [ &#123; y: 7, x: 1 &#125;, &#123; y: 7, x: 4 &#125; ], [ &#123; y: 8, x: 1 &#125;, &#123; y: 8, x: 2 &#125;, &#123; y: 8, x: 3 &#125;, &#123; y: 8, x: 4 &#125; ], [ &#123; y: 9, x: 0 &#125;, &#123; y: 9, x: 1 &#125; ] ]; // tips const tips = &#123; &quot;21222324&quot;: &quot;赫拉利将告诉你人类是如何从动物变成上帝&quot;, &quot;40414243&quot;: &quot;对两次世界大战的哲学思考，直面存在的危机&quot;, &quot;81828384&quot;: &quot;看萧红写的这书名还以为是一条河的历史&quot;, &quot;9091&quot;: &quot;鲁迅先生的短篇小说集，里面有《狂人日记》&quot;, &quot;64656667&quot;: &quot;天下合久必分，分久必合&quot;, &quot;46474849&quot;: &quot;与达尔文《物种起源论》及哥白尼《天体运行论》并称为人类三大思想革命的经典之作&quot;, &quot;262728&quot;: &quot;三位艺术天才的非凡人生，罗曼罗兰著&quot;, &quot;5678&quot;: &quot;证明你上过中学的又一个有力佐证，冰心奶奶如是说&quot;, &quot;11121&quot;: &quot;我们都是故事外的人——阿尔贝·加缪&quot;, &quot;13233343&quot;: &quot;一种追求简单生活的价值观&quot;, &quot;415161718191&quot;: &quot;余华手下一本关于记忆的长篇小说&quot;, &quot;647484&quot;: &quot;走遍万水千山，泪尽撒哈拉&quot;, &quot;2737475767&quot;: &quot;达康书记别低头，皇冠会掉&quot;, &quot;81828&quot;: &quot;中国四大名著之一&quot; &#125;; // 创建 12 * 8 的方格 const unit = []; // 所有单元格 二维数组 const unit_block = []; // 需要渲染的单元格 const selectUnit = &#123; isRow: true, unit: [] &#125;; // 选中后的单元格 // 创建材质 const unitTexture = PIXI.Texture.fromImage(&quot;./assets/images/unit.svg&quot;); const unitBlockTexture = PIXI.Texture.fromImage( &quot;./assets/images/unit-block.svg&quot; ); const unitBlockActiveTexture = PIXI.Texture.fromImage( &quot;./assets/images/unit-block-active.svg&quot; ); // 创建舞台 const container = new PIXI.Container(); container.x = 0; container.y = 0; // 倒计时 const Countdown = &#123; down(callBack, success) &#123; clearInterval(this.Interval); callBack( success === true ? this.countTime * 60 - this.time / 1000 : &quot;时间结束&quot; ); &#125;, check(v) &#123; if (v &lt; 10) &#123; return &quot;0&quot; + v; &#125; else &#123; return v; &#125; &#125;, start(time, el, callBack) &#123; this.countTime = time; var endDate = new Date().getTime() + time * 60 * 1000; this.Interval = setInterval(() =&gt; &#123; this.time = endDate - new Date().getTime(); if (this.time &lt;= 0) this.down(callBack); var m = parseInt((this.time / 1000 / 60) % 60, 10); var s = parseInt((this.time / 1000) % 60, 10); var ms = parseInt(this.time % 1000, 10); el.innerText = this.check(m) + &quot;:&quot; + this.check(s); &#125;, 1); &#125; &#125;; // es7 setTimeout(() =&gt; &#123; initGame(); &#125;, 300); async function initGame() &#123; await (() =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; mask.classList.add(&quot;mask-in&quot;); setTimeout(() =&gt; &#123; resolve(); &#125;, 300); &#125;); &#125;)(); // 创建画布 const app = new PIXI.Application( table.x * unit_size.width, table.y * unit_size.height, &#123; backgroundColor: 0xf1c16c, antialias: true, view: document.querySelector(&quot;#game&quot;), resolution: window.devicePixelRatio &#125; ); app.stage.interactive = true; app.stage.addChild(container); // 绘制表格 creatTable(table, unit_data, async function() &#123; await (() =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; mask.innerText = &quot;初始化完成,祝您玩的开心&quot;; resolve(); &#125;, 1000); &#125;); &#125;)(); await setTimeout(() =&gt; &#123; mask.classList.add(&quot;mask-out&quot;); console.log(&quot;初始化完成&quot;); &#125;, 500); &#125;); &#125; function creatTable(table, block, callBack) &#123; let row = table.x; let col = table.y; let index = 0; let width = unit_size.width * table.x * unit_size.width; let height = unit_size.width * table.y * unit_size.height; let i = 0; while (i &lt; row) &#123; unit.push([]); let k = 0; while (k &lt; col) &#123; let sprite = new PIXI.Sprite(unitTexture); let unitContainer = new PIXI.Container(); let x = (k * unit_size.width) % width; let y = (i * unit_size.height) % height; sprite.interactive = true; sprite.isDown = false; sprite.isEmpty = true; sprite.anchor.set(0, 0); sprite.width = unit_size.width; sprite.height = unit_size.height; sprite.index = index++; // 唯一id unitContainer.width = unit_size.width; unitContainer.height = unit_size.height; unitContainer.x = x; unitContainer.y = y; sprite.x = 0; sprite.y = 0; sprite.X = x / unit_size.width; // x坐标 sprite.Y = y / unit_size.height; // y 坐标 unit[i].push(sprite); unitContainer.addChild(sprite); container.addChild(unitContainer); k++; &#125; i++; &#125; // 添加事件 for (let row = 0, uLen = unit.length; row &lt; uLen; row++) &#123; add: for (let col = 0, len = unit[row].length; col &lt; len; col++) &#123; // console.log(unit[row][col].x / unit_size.width, unit[row][col].y / unit_size.height); for (let k = 0, fLen = block[row].length; k &lt; fLen; k++) &#123; if (block[row][k].x === col &amp;&amp; block[row][k].y === row) &#123; unit[row][col].isEmpty = false; unit[row][col].texture = unitBlockTexture; unit[row][col].buttonMode = true; unit[row][col].on(&quot;tap&quot;, onClick); unit_block.push(unit[row][col]); continue add; &#125; &#125; &#125; &#125; // 绘制边框 drawBorder(table, unit_data, container); typeof callBack === &quot;function&quot; ? callBack() : void 0; &#125; function onClick() &#123; input.focus(); const X = this.X, Y = this.Y; let cols = [], rows = unit[Y]; // 重置默认 reset(unit_block); this.isDown = !this.isDown; unit.forEach(row =&gt; &#123; if (row[X].X === X) cols.push(row[X]); &#125;); if (this.selectRow !== undefined) &#123; if (this.isDown &amp;&amp; this.selectRow) &#123; renderCol(X, Y, cols, rows); &#125; else &#123; renderRow(X, Y, rows, cols); &#125; &#125; else &#123; if (this.isDown) &#123; renderRow(X, Y, rows, cols); &#125; else &#123; renderCol(X, Y, cols, rows); &#125; &#125; let key = selectUnit.unit.reduce((total, unit) =&gt; &#123; return total + unit.index.toString(); &#125;, &quot;&quot;); tipsEl.innerText = tips[key]; console.log(key); &#125; // 渲染行 function renderRow(x, y, row, col) &#123; let unit = aroundUnit(row, x, y, true); let len = unit.length; // 如果临近元素为为空 (1 代表自身) 渲染列 if (len &lt;= 1) &#123; renderCol(x, y, col, row); return; &#125; unit.forEach(item =&gt; &#123; item.texture = unitBlockActiveTexture; item.selectRow = true; &#125;); let storUnit = stor(unit); selectUnit.isRow = true; selectUnit.unit = storUnit; &#125; // 渲染列 function renderCol(x, y, col, row) &#123; let unit = aroundUnit(col, x, y, false); let len = unit.length; // 如果临近元素为空 (1 代表自身) 渲染行 if (len &lt;= 1) &#123; renderRow(x, y, row, col, true); return; &#125; unit.forEach(item =&gt; &#123; item.texture = unitBlockActiveTexture; item.selectRow = false; &#125;); let storUnit = stor(unit); selectUnit.isRow = false; selectUnit.unit = storUnit; &#125; // 获取相邻元素 arry 一维数组 行 或者 列 function aroundUnit(arry, x, y, selectRow) &#123; let n = selectRow ? x : y; let len = arry.length; let unit = []; for (let i = 0; i &lt; len; i++) &#123; if (arry[n + i] &amp;&amp; arry[n + i].isEmpty) break; if (arry[n + i]) &#123; unit.push(arry[n + i]); &#125; &#125; for (let i = 1; i &lt; len; i++) &#123; if (arry[n - i] &amp;&amp; arry[n - i].isEmpty) break; if (arry[n - i]) unit.push(arry[n - i]); &#125; return unit; &#125; // 重置视图 function reset(unit) &#123; unit.forEach(item =&gt; &#123; item.isDown = false; item.texture = unitBlockTexture; &#125;); &#125; // 排序 function stor(unit) &#123; function compare(property) &#123; return function(a, b) &#123; var value1 = a[property]; var value2 = b[property]; return value1 - value2; &#125;; &#125; return unit.sort(compare(&quot;index&quot;)); &#125; function drawBorder(table, block, ctx) &#123; let row = table.x, col = table.y; let containerWidth = row * unit_size.width, containerHeight = col * unit_size.height; let startY = unit_size.height, startX = unit_size.width; drawLine( &#123; width: 1, color: 0xb38743, alpha: 1 &#125;, ctx, containerWidth, containerHeight, startX, startY, row, col ); &#125; // 绘制线条 function drawLine(lineStyle, ctx, width, height, X, Y, col, row) &#123; let i = 1, n = 1; const graphics = new PIXI.Graphics(); // 绘制行 while (i &lt; row) &#123; graphics.beginFill(); graphics.lineStyle(lineStyle.width, lineStyle.color, lineStyle.alpha); graphics.moveTo(0, Y * i); graphics.lineTo(width, Y * i); graphics.endFill(); ctx.addChild(graphics); i++; &#125; // 绘制列 while (n &lt; col) &#123; graphics.beginFill(); graphics.lineStyle(lineStyle.width, lineStyle.color, lineStyle.alpha); graphics.moveTo(X * n, 0); graphics.lineTo(X * n, height); graphics.endFill(); ctx.addChild(graphics); n++; &#125; &#125; // 解决键盘遮住 输入框 $(document).on(&quot;focus&quot;, &quot;input&quot;, function(e) &#123; setTimeout( () =&gt; &#123; // this.scrollIntoViewIfNeeded(false); this.scrollIntoView(&#123; block: &quot;end&quot;, behavior: &quot;smooth&quot; &#125;); &#125;, device.ios ? 200 : 0 ); &#125;); // 输入 $(&quot;.input-container&quot;).on(&quot;click&quot;, &quot;.game-input-send&quot;, async function(e) &#123; let value = $.trim(input.value); if (value.length &gt; selectUnit.unit.length) &#123; modal.toast(`最大可输入字数为$&#123;selectUnit.unit.length&#125;个`); return false; &#125; let param = selectUnit.unit.map((item, index) =&gt; &#123; return &#123; value: value.charAt(index), x: item.X, y: item.Y, index: item.index &#125;; &#125;); console.log(param); let flag = await new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; async: true, type: &quot;post&quot;, url: &quot;./game.php&quot;, data: &#123; data: param &#125;, success: function(data) &#123; if (data.status === &quot;0&quot;) &#123; modal.toast(&quot;填错了哦&quot;); input.value = &quot;&quot;; resolve(false); &#125; else &#123; resolve(true); &#125; &#125;, error: function(err) &#123; console.log(err); &#125; &#125;); &#125;); if (!flag) return; [...value].forEach((chart, index) =&gt; &#123; if (selectUnit.unit[index].parent.children.length &gt; 1) &#123; selectUnit.unit[index].parent.children.forEach((sprite, i) =&gt; &#123; if (sprite.type === &quot;text&quot;) sprite.text = chart; &#125;); return false; &#125; let richText = new PIXI.Text(chart, fontStyle); richText.type = &quot;text&quot;; richText.anchor.set(0.5); richText.x = selectUnit.unit[index].parent.width / 2; richText.y = selectUnit.unit[index].parent.height / 2; selectUnit.unit[index].parent.addChild(richText); // container.addChild(richText); &#125;); input.value = &quot;&quot;; &#125;);&#125;); PHP后端就比较容易了,前端传每一个字格 id 以及值，后端验证字格 id 值 就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** @Author: Edward* @Date: 2018-05-02 23:27:31* @Last Modified by: Edward* @Email: 809537981@qq.com* @Last Modified time: 2018-05-03 16:26:08*/header(&#x27;Content-Type:application/json; charset=utf-8&#x27;);$post = $_POST[&#x27;data&#x27;];$data = [ &#x27;1&#x27; =&gt; &#x27;局&#x27;, &#x27;11&#x27; =&gt; &#x27;外&#x27;, &#x27;5&#x27; =&gt; &#x27;繁&#x27;, &#x27;6&#x27; =&gt; &#x27;星&#x27;, &#x27;7&#x27; =&gt; &#x27;春&#x27;, &#x27;8&#x27; =&gt; &#x27;水&#x27;, &#x27;13&#x27; =&gt; &#x27;极&#x27;, &#x27;33&#x27; =&gt; &#x27;主&#x27;, &#x27;18&#x27; =&gt; &#x27;浒&#x27;, &#x27;21&#x27; =&gt; &#x27;人&#x27;, &#x27;22&#x27; =&gt; &#x27;类&#x27;, &#x27;23&#x27; =&gt; &#x27;简&#x27;, &#x27;24&#x27; =&gt; &#x27;史&#x27;, &#x27;28&#x27; =&gt; &#x27;传&#x27;, &#x27;27&#x27; =&gt; &#x27;人&#x27;, &#x27;26&#x27; =&gt; &#x27;名&#x27;, &#x27;37&#x27; =&gt; &#x27;民&#x27;, &#x27;46&#x27; =&gt; &#x27;梦&#x27;, &#x27;47&#x27; =&gt; &#x27;的&#x27;, &#x27;57&#x27; =&gt; &#x27;名&#x27;, &#x27;48&#x27; =&gt; &#x27;解&#x27;, &#x27;49&#x27; =&gt; &#x27;析&#x27;, &#x27;64&#x27; =&gt; &#x27;三&#x27;, &#x27;65&#x27; =&gt; &#x27;国&#x27;, &#x27;66&#x27; =&gt; &#x27;演&#x27;, &#x27;67&#x27; =&gt; &#x27;义&#x27;, &#x27;67&#x27; =&gt; &#x27;义&#x27;, &#x27;74&#x27; =&gt; &#x27;毛&#x27;, &#x27;81&#x27; =&gt; &#x27;呼&#x27;, &#x27;82&#x27; =&gt; &#x27;兰&#x27;, &#x27;83&#x27; =&gt; &#x27;河&#x27;, &#x27;84&#x27; =&gt; &#x27;传&#x27;, &#x27;40&#x27; =&gt; &#x27;存&#x27;, &#x27;41&#x27; =&gt; &#x27;在&#x27;, &#x27;42&#x27; =&gt; &#x27;主&#x27;, &#x27;43&#x27; =&gt; &#x27;义&#x27;, &#x27;51&#x27; =&gt; &#x27;细&#x27;, &#x27;61&#x27; =&gt; &#x27;雨&#x27;, &#x27;71&#x27; =&gt; &#x27;中&#x27;, &#x27;81&#x27; =&gt; &#x27;呼&#x27;, &#x27;90&#x27; =&gt; &#x27;呐&#x27;, &#x27;91&#x27; =&gt; &#x27;喊&#x27;,];$flag = false;foreach($post as $index =&gt; $arry) &#123; if ($data[$arry[&#x27;index&#x27;]] == $arry[&#x27;value&#x27;]) &#123; $flag = true; &#125; else &#123; $flag = false; &#125;&#125;if ($flag) &#123; echo &#x27;&#123;&quot;status&quot;: &quot;1&quot;&#125;&#x27;;&#125; else &#123; echo &#x27;&#123;&quot;status&quot;: &quot;0&quot;&#125;&#x27;;&#125; 收工~","categories":[{"name":"pixijs","slug":"pixijs","permalink":"https://sunday9787.github.io/categories/pixijs/"}],"tags":[{"name":"小游戏","slug":"小游戏","permalink":"https://sunday9787.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"}]}],"categories":[{"name":"webpack","slug":"webpack","permalink":"https://sunday9787.github.io/categories/webpack/"},{"name":"科学上网","slug":"科学上网","permalink":"https://sunday9787.github.io/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Vue","slug":"Vue","permalink":"https://sunday9787.github.io/categories/Vue/"},{"name":"pixijs","slug":"pixijs","permalink":"https://sunday9787.github.io/categories/pixijs/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://sunday9787.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"webpack","slug":"webpack","permalink":"https://sunday9787.github.io/tags/webpack/"},{"name":"ts","slug":"ts","permalink":"https://sunday9787.github.io/tags/ts/"},{"name":"vue","slug":"vue","permalink":"https://sunday9787.github.io/tags/vue/"},{"name":"v2ray","slug":"v2ray","permalink":"https://sunday9787.github.io/tags/v2ray/"},{"name":"小飞机","slug":"小飞机","permalink":"https://sunday9787.github.io/tags/%E5%B0%8F%E9%A3%9E%E6%9C%BA/"},{"name":"dom","slug":"dom","permalink":"https://sunday9787.github.io/tags/dom/"},{"name":"element-form","slug":"element-form","permalink":"https://sunday9787.github.io/tags/element-form/"},{"name":"$nextTick","slug":"nextTick","permalink":"https://sunday9787.github.io/tags/nextTick/"},{"name":"web安全","slug":"web安全","permalink":"https://sunday9787.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"小游戏","slug":"小游戏","permalink":"https://sunday9787.github.io/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"}]}